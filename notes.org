* shell pipeline
spotify-favs | sort | uniq -c | sort -n -r | awk '{if ($1 >= 4) { print $0 }}'

* DONE save token
CLOSED: [2018-07-07 Sat 11:27]
- save
  - get auth token
  - encode to gob bytes
  - encode using key derived from clientSecret
  - save to disk

- load
  - load from disk
  - decode using key derived from clientSecret
  - decode from gob bytes

*** DONE encrypting
CLOSED: [2018-07-07 Sat 11:27]
- dk, err := scrypt.Key([]byte("some password"), salt, 32768, 8, 1, 32)
- then use AES

* DONE check if token *ever* expires
CLOSED: [2018-07-07 Sat 13:07]
if it doesn't, we don't have to re-save after load

- it does expire, but let's see what happens if I try to use an expired
  token, if it auto-refreshes or what

- oh heck yeah, expired tokens auto-refresh so we good

* DONE is there a way to save the ID and Secret at build time?
CLOSED: [2018-07-07 Sat 12:53]
turns out yes there is:

go build -ldflags "-X main.<variable>=$<NAME>"

* DONE use ~open~ to just open the url for the user
instead of making them copy and paste a link, maybe that would be better

* DONE do songkick searches to get the songkick ids
- open search
- wait on stdin for the id
- https://www.songkick.com/search?utf8=âœ“&query=${artist}

- make sure to url encode the artist name

* make playlist from songkick url
- eg: https://www.songkick.com/concerts/33692814-royal-they-at-alphaville
- scrape Line-up, add latest album from each band to playlist

  babysteps
  - [X] create playlist
  - [X] add latest album for 1 artist by ID to playlist
  - [ ] artist search -> spotify ID
  - [ ] scrape lineup (page -> [artistIDs])

* conditionally re-save the token, only if it's changed
- saving is somewhat expensive because of scrypt, so we shouldn't do it all the dang time, let's just do it only if the token has changed.

* command line flags
- ~-logout~: remove the auth token

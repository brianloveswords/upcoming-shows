* shell pipeline
spotify-favs | sort | uniq -c | sort -n -r | awk '{if ($1 >= 4) { print $0 }}'

* DONE save token
CLOSED: [2018-07-07 Sat 11:27]
- save
  - get auth token
  - encode to gob bytes
  - encode using key derived from clientSecret
  - save to disk

- load
  - load from disk
  - decode using key derived from clientSecret
  - decode from gob bytes

*** DONE encrypting
CLOSED: [2018-07-07 Sat 11:27]
- dk, err := scrypt.Key([]byte("some password"), salt, 32768, 8, 1, 32)
- then use AES

* DONE check if token *ever* expires
CLOSED: [2018-07-07 Sat 13:07]
if it doesn't, we don't have to re-save after load

- it does expire, but let's see what happens if I try to use an expired
  token, if it auto-refreshes or what

- oh heck yeah, expired tokens auto-refresh so we good

* DONE is there a way to save the ID and Secret at build time?
CLOSED: [2018-07-07 Sat 12:53]
turns out yes there is:

go build -ldflags "-X main.<variable>=$<NAME>"

* DONE use ~open~ to just open the url for the user
instead of making them copy and paste a link, maybe that would be better

* DONE do songkick searches to get the songkick ids
- open search
- wait on stdin for the id
- https://www.songkick.com/search?utf8=âœ“&query=${artist}

- make sure to url encode the artist name

* DONE make playlist from songkick url
- eg: https://www.songkick.com/concerts/33692814-royal-they-at-alphaville
- scrape Line-up, add latest album from each band to playlist

  babysteps
  - [X] create playlist
  - [X] add latest album for 1 artist by ID to playlist
  - [X] artist search -> spotify ID
  - [X] scrape lineup (page -> [artistIDs])

* DONE conditionally re-save the token, only if it's changed
- saving is somewhat expensive because of scrypt, so we shouldn't do it all the dang time, let's just do it only if the token has changed.

* command line flags
- [ ] spotify auth clear
- [ ] spotify auth debug

- [X] spotify next
- [X] spotify pause
- [X] spotify play

- [X] spotify playing fav

- [ ] spotify playlist create ...

* DONE printing
think about:

- which functions should print at all, and which are "internal" and should shut the fuck up and just return different types of errors?
- different levels of verbose? debug/verbose/normal/silent
- how to structure debugging printer so it's ~grep~ friendly
- 1 global logger to rule them all
- everything prints to stderr except CmdOutput
- color optional?
- env var, LOGLEVEL:<debug|verbose|normal|silent>

logger.Debug

- [debug] playlist:create:request-songkick-page: requesting page
- [debug] playlist:create:parse-songkick-page: parsing page
- [debug] playlist:create:parse-songkick-page: extracted xyz
- [debug] playlist:create:parse-songkick-page: couldn't do the thing

logger.Verbose

logger.Normal

logger.CmdOutput


* command and flag parser

CommandTree{
    Name: "spotify",
    Commands: []Command{
        Command{
          Name:    "next",
          Aliases: []string{"skip"},
          Help:    "skip to the next track",
        }
        Command{
          Name:    "play",
          Help:    "play the current track",
        }
    }
}
